package org.typefactory.assertions;

import java.util.Objects;
import org.assertj.core.api.AbstractCharSequenceAssert;
import org.typefactory.CharSequenceType;
import org.typefactory.StringType;
import org.typefactory.Type;

/**
 * Abstract base class for {@link StringType} specific assertions - Generated by CustomAssertionGenerator.
 */
@SuppressWarnings("java:S119") // Generic parameter naming
public abstract class AbstractStringTypeAssert<SELF extends AbstractStringTypeAssert<SELF, ACTUAL>, ACTUAL extends StringType> extends
    AbstractCharSequenceAssert<SELF, ACTUAL> {

  /**
   * Creates a new <code>{@link AbstractStringTypeAssert}</code> to make assertions on actual StringType.
   * @param actual the StringType we want to make assertions on.
   */
  protected AbstractStringTypeAssert(ACTUAL actual, Class<SELF> selfType) {
    super(actual, selfType);
  }

  private String simpleClassNameOfActual() {
    return actual == null ? "custom type extending StringType" : actual.getClass().getSimpleName();
  }

  private String valueOfActual() {
    return Type.isNull(actual) ? "null" : Objects.toString(actual.value());
  }

  /**
   * Verifies that the actual StringType's value is equal to the given one.
   * @param expected the given value to compare the actual StringType's value to.
   * @return this assertion object.
   * @throws AssertionError - if the actual StringType's value is not equal to the given one.
   */
  public SELF hasValue(final String expected) {
    if (expected == null) {
      if (Type.isNull(actual)) {
        return myself;
      } else {
        throw failure("Expected %s to be null but was <%s>", simpleClassNameOfActual(), valueOfActual());
      }
    }
    if (!Objects.equals(actual.value(), expected)) {
      throw failureWithActualExpected(
          valueOfActual(), expected,
          "Expected %s value to be <%s> but was <%s>",
          simpleClassNameOfActual(), expected, valueOfActual());
    }
    return myself;
  }

  @Override
  public void isNull() {
    if (Type.isNull(actual)) {
      return;
    }
    throw failure("Expected %s value to be null but was <%s>", simpleClassNameOfActual(), valueOfActual());
  }

  @Override
  public SELF isNotNull() {
    if (Type.isNull(actual)) {
      throw failure("Expected %s value to be non-null but was null", simpleClassNameOfActual());
    }
    return myself;
  }

  @Override
  public void isEmpty() {
    if (!CharSequenceType.isEmpty(actual)) {
      throw failure("Expected %s value to be empty but was <%s>", simpleClassNameOfActual(), valueOfActual());
    }
  }

  @Override
  public SELF isNotEmpty() {
    if (CharSequenceType.isEmpty(actual)) {
      throw failure("Expected %s value to be non-empty but was empty", simpleClassNameOfActual());
    }
    return myself;
  }

  @Override
  public SELF isBlank() {
    if (!CharSequenceType.isBlank(actual)) {
      throw failure("Expected %s value to be blank but was <%s>", simpleClassNameOfActual(), valueOfActual());
    }
    return myself;
  }

  @Override
  public SELF isNotBlank() {
    if (CharSequenceType.isBlank(actual)) {
      throw failure("Expected %s value to be non-blank but was blank <%s>", simpleClassNameOfActual(), valueOfActual());
    }
    return myself;
  }
}
