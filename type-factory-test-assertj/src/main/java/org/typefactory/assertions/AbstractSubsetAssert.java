package org.typefactory.assertions;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.assertj.core.api.AbstractObjectAssert;
import org.typefactory.Category;
import org.typefactory.Subset;
import org.typefactory.impl.SubsetWithCategories;

/**
 * Abstract base class for {@link Subset} specific assertions - Generated by CustomAssertionGenerator.
 */
@SuppressWarnings("java:S119") // Generic parameter naming
public abstract class AbstractSubsetAssert<SELF extends AbstractSubsetAssert<SELF, ACTUAL>, ACTUAL extends Subset> extends
    AbstractObjectAssert<SELF, ACTUAL> {

  /**
   * Creates a new <code>{@link AbstractSubsetAssert}</code> to make assertions on actual Subset.
   *
   * @param actual the Subset we want to make assertions on.
   */
  protected AbstractSubsetAssert(ACTUAL actual, Class<SELF> selfType) {
    super(actual, selfType);
  }


  /**
   * Verifies that the actual Subset is empty.
   *
   * @return this assertion object.
   * @throws AssertionError - if the actual Subset is not empty.
   */
  public SELF isEmpty() {
    isNotNull();
    if (actual.isNotEmpty()) {
      throw failure("Expecting that actual Subset is empty but it is not.");
    }
    return myself;
  }

  /**
   * Verifies that the actual Subset is not empty.
   *
   * @return this assertion object.
   * @throws AssertionError - if the actual Subset is empty.
   */
  public SELF isNotEmpty() {
    isNotNull();
    if (!actual.isNotEmpty()) {
      throw failure("Expecting that actual Subset is not empty but it is.");
    }
    return myself;
  }


  public SELF containsCharacter(final char expectedCharacter) {
    isNotEmpty();
    if (!actual.contains(expectedCharacter)) {
      throw failure("Subset did not contain expected character\nExpected to contain: %s",
          AssertionUtils.unicodeHexCode(expectedCharacter));
    }
    return myself;
  }

  public SELF containsAllCharacters(final char... expectedCharacters) {
    isNotEmpty();
    final StringBuilder expectedCharactersString = new StringBuilder();
    final StringBuilder charactersNotInSubset = new StringBuilder();
    for (char expectedCharacter : expectedCharacters) {
      expectedCharactersString.append(expectedCharacter).append(",");
      if (!actual.contains(expectedCharacter)) {
        charactersNotInSubset.append(expectedCharacter).append(",");
      }
    }
    if (charactersNotInSubset.length() > 0) {
      charactersNotInSubset.setLength(charactersNotInSubset.length() - 1);
      expectedCharactersString.setLength(expectedCharactersString.length() - 1);
      throw failure("Subset did not contain all expected characters\nExpected to contain: %s\nContained only: %s",
          expectedCharactersString.toString(), charactersNotInSubset.toString());
    }
    return myself;
  }

  public SELF containsCodepoint(final int expectedCodePoint) {
    isNotEmpty();
    if (!actual.contains(expectedCodePoint)) {
      throw failure("Subset did not contain expected code-point\nExpected to contain: %s",
          AssertionUtils.unicodeHexCode(expectedCodePoint));
    }
    return myself;
  }

  public SELF containsAllCodepoint(final int... expectedCodePoints) {
    isNotEmpty();
    final StringBuilder expectedCodePointString = new StringBuilder();
    final StringBuilder codePointsNotInSubset = new StringBuilder();
    for (int expectedCodePoint : expectedCodePoints) {
      expectedCodePointString.appendCodePoint(expectedCodePoint).append(",");
      if (!actual.contains(expectedCodePoint)) {
        codePointsNotInSubset.appendCodePoint(expectedCodePoint).append(",");
      }
    }
    if (codePointsNotInSubset.length() > 0) {
      codePointsNotInSubset.setLength(codePointsNotInSubset.length() - 1);
      expectedCodePointString.setLength(expectedCodePointString.length() - 1);
      throw failure("Subset did not contain all expected code-points\nExpected to contain: %s\nContained only: %s",
          expectedCodePointString.toString(), codePointsNotInSubset.toString());
    }
    return myself;
  }

  public SELF includesCategory(final Category expectedCategory) {
    isNotNull();
    if (!actual.includes(expectedCategory)) {
      throw failure("Subset did not contain expected category\nExpected to contain: %s", expectedCategory.name());
    }
    return myself;
  }

  public SELF includesAllCategories(final Category... expectedCategories) {
    isNotNull();
    final StringBuilder expectedCategoriesString = new StringBuilder();
    final StringBuilder categoriesNotInSubset = new StringBuilder();
    for (Category expectedCategory : expectedCategories) {
      expectedCategoriesString.append(expectedCategory.name()).append(",");
      if (!actual.includes(expectedCategory)) {
        categoriesNotInSubset.append(expectedCategory.name()).append(",");
      }
    }
    if (categoriesNotInSubset.length() > 0) {
      categoriesNotInSubset.setLength(categoriesNotInSubset.length() - 1);
      expectedCategoriesString.setLength(expectedCategoriesString.length() - 1);
      throw failure("Subset did not contain all expected categories\nExpected to contain: %s\nContained only: %s",
          expectedCategoriesString.toString(), categoriesNotInSubset.toString());
    }
    return myself;
  }

  public SELF includesExactlyCategories(final Category... expectedCategories) {
    isNotNull();
    final Set<Category> actualSubsetCategories = getActualSubsetCategories();
    final Set<Category> contained = new HashSet<>();
    final Set<Category> notContained = new HashSet<>();
    for (Category expectedCategory : expectedCategories) {
      if (actualSubsetCategories.contains(expectedCategory)) {
        contained.add(expectedCategory);
      } else {
        notContained.add(expectedCategory);
      }
    }
    if (!notContained.isEmpty()) {
      throw failureWithActualExpected(
          actualSubsetCategories, List.of(expectedCategories),
          "Subset did not contain exactly the expected categories\nContained only: %s\nDid not contain %s",
          contained.stream().map(Enum::name).collect(Collectors.joining(", ")),
          notContained.stream().map(Enum::name).collect(Collectors.joining(", ")));
    }
    return myself;
  }

  private Set<Category> getActualSubsetCategories() {
    final HashSet<Category> result = new HashSet<>();
    if (actual instanceof SubsetWithCategories subsetWithCategories) {
      final long subsetCategoryBitFlags = subsetWithCategories.unicodeCategoryBitFlags();
      for (Category category : Category.values()) {
        if ((subsetCategoryBitFlags & category.bitMask) == category.bitMask) {
          result.add(category);
        }
      }
    }
    return result;
  }

}
